# SingleProcessingOfLargeFile

## 问题

有一个`100GB`的文件，里面内容是文本

要求：

- 找出第一个不重复的词

- 只允许扫一遍原文件

- 尽量少的`IO`

- 内存限制`16G`

- 随机字符串，每行一个字符串，长度范围为`1-100`

提示：

- 注意代码风格与规范，添加必要的测试、注释和文档

- 注意各类边界情况和异常处理，尝试优化性能


## 思路

1. 尽量的少的`I/O`，。对于每个词，最后有两个字节的换行符。每个长度范围为`1-100`字节的词，共有`2`的`800`次方种组合。选用`int64`表示每个词出现的位置，因为对于`100G`的文件有`2^31 - 1 < 100 * 2^30 / 3 < 2^63 - 1 `，其中`3`表示最小字符串长度`1`加上`2`字节的换行符。整个内存除了存放分次读入的文件外，还存放两张位图和一个队列。IO次数如下：

对于位图有`2^32 / (8 * 2^30) = 0.5GB`，两张位图则有`1GB`。设分`x`次`I/O`，则每次读入文件大小为`100 / x`，此时存放不重复词的队列最大也为`100 \ x`，故有`100 / x + 100 / x + 1 < 16`，解得`x > 13.33`，取`x = 14`。


2. 维护`bitmap`。使用一个位图标志访问过的词，另一个位图标志重复的词。该过程使用布隆过滤器的思想，构建一组哈希函数，对于每一个词，逐次使用哈希函数组的哈希函数计算出哈希值，接着在位图的相应比特位置置`1`。每次查询一个词是否存在时，也是逐次使用哈希函数组的哈希函数计算出哈希值，接着查看在位图的相应比特位置有`0`，如果有则该词一定未存在，把该词及其位置信息放入不重复词的队列中；而如果在位图的相应比特位置都为`1`，则该元素有可能重复，此时进行维护队列，比如队列不存在此元素则加入，否则删除重复的元素。这种布隆原理查找效率比较高，缺点是可能会哈希冲突。根据布隆过滤器原理可通过使用足够大的位图和一定数量的哈希函数来降低错误率。

3. 维护一个队列。在扫描词时，如果是重复访问了，就把该词从当前内存中的队列出队；如果是第一次访问，则加入队列，此时超出内存限制，则将队列写到硬盘

4. 最后结算。先扫描硬盘中的词，如果词在第二张位图中则该词是重复词，继续扫描；如果不是则该词是第一个最早不重复的词。如果在硬盘没找到则找内存队列中的词，队列中第一个就是第一个最早不重复词。如果硬盘和内存中都没有，则不存在不重复的词。


## 其他

- `bitmap.go`文件存放的是位图数据结构的源码

- `handleFile.go`文件的源码是主要代码

- `util.go`文件是一组哈希函数用于计算哈希值

- `main.go`是主程序的入口

- `main_test.go`用于生成测试用的`100G`文件

